<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Veltrax — Real‑Time Approval Lift (Same Portfolio Loss)</title>
<style>
  :root{
    --vx-primary:#4c8dff; --vx-bg:#131417; --vx-surface:#1b1d23; --vx-surface-2:#20232b;
    --vx-border:#2c2f36; --vx-text:#e6e7eb; --vx-muted:#9aa1b3; --vx-good:#4cff88; --vx-danger:#ff453a; --vx-ring:rgba(76,141,255,.45);
  }
  *,*::before,*::after{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial;color:var(--vx-text);background:radial-gradient(1000px 400px at 50% -200px, rgba(111,66,193,.25), transparent 60%), var(--vx-bg)}
  .container{max-width:1200px;margin:0 auto;padding:0 24px}
  .hero{padding:36px 0 8px}
  .hero h1{margin:8px 0 6px;font-size:40px;line-height:1.15}
  .muted{color:var(--vx-muted)}
  .card{background:linear-gradient(180deg,var(--vx-surface),var(--vx-surface-2));border:1px solid var(--vx-border);border-radius:16px;padding:20px;box-shadow:0 1px 0 rgba(0,0,0,.25)}
  .row{display:grid;gap:16px}
  @media (min-width: 980px){.row.cols-2{grid-template-columns:1.1fr .9fr}}
  label{font-size:14px;font-weight:700;display:block;margin-bottom:6px}
  label small{display:block;color:var(--vx-muted);font-weight:400;margin-top:4px}
  input[type=range]{width:100%}
  input[type=number]{width:140px;background:#151821;border:1px solid var(--vx-border);border-radius:10px;color:var(--vx-text);padding:10px;font-size:15px}
  .stack{display:grid;gap:18px}
  .kpi-grid{display:grid;gap:12px}
  @media (min-width:720px){.kpi-grid{grid-template-columns:repeat(4,1fr)}}
  .kpi{background:#16181f;border:1px solid var(--vx-border);border-radius:12px;padding:14px}
  .kpi .label{font-size:12px;color:var(--vx-muted);margin-bottom:6px}
  .kpi .value{font-size:22px;font-weight:800}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .chart{height:420px;border:1px solid var(--vx-border);border-radius:14px;position:relative;background:#0f1219}
  .legend{display:flex;gap:14px;position:absolute;bottom:14px;left:14px;font-size:12px;color:var(--vx-muted);flex-wrap:wrap}
  .swatch{width:12px;height:12px;border-radius:50%;display:inline-block;margin-right:6px}
  footer{border-top:1px solid var(--vx-border);margin-top:36px;padding:24px 0 56px}
</style>
</head>
<body>
  <header class="container hero">
    <div style="display:flex;align-items:center;gap:10px">
      <svg width="22" height="22" viewBox="0 0 64 64" aria-hidden="true"><rect x="6" y="10" width="52" height="12" rx="6" fill="#fff"/><rect x="6" y="30" width="42" height="12" rx="6" fill="#fff"/><rect x="6" y="50" width="26" height="8" rx="4" fill="#6F42C1"/></svg>
      <span class="muted" style="letter-spacing:.2em;font-size:11px">VELTRAX</span>
    </div>
    <h1>Real‑Time Approval Lift — Same Portfolio Loss</h1>
    <p class="muted" style="max-width:840px">Unified, local scoring approves more good customers without increasing portfolio loss. Adjust the assumptions and see the lift.</p>
  </header>

  <main class="container stack">
    <section class="row cols-2">
      <!-- Assumptions -->
      <div class="card" aria-labelledby="assumptions-title">
        <h2 id="assumptions-title" style="margin:0 0 10px;font-size:18px">Assumptions</h2>
        <div class="row" style="grid-template-columns:1fr 1fr;gap:18px">
          <div>
            <label class="mono">Applications per day (<span id="out-apps">200,000</span>)<small>Total inbound apps/cards</small></label>
            <input id="apps" type="range" min="1000" max="500000" step="1000" value="200000" />
          </div>
          <div>
            <label class="mono">Approval rate (<span id="out-approve">40%</span>)<small>Current approvals as a share of apps</small></label>
            <input id="approve" type="range" min="5" max="95" step="1" value="40" />
          </div>
          <div>
            <label class="mono">Avg margin per approved ($)<small>Net present value per good approval</small></label>
            <input id="margin" type="number" min="0" step="1" value="120" />
          </div>
          <div>
            <label class="mono">Current loss rate (<span id="out-loss">5.0%</span>)<small>Defaults/charge‑offs among approved</small></label>
            <input id="loss" type="range" min="0.1" max="20" step="0.1" value="5" />
          </div>
          <div>
            <label class="mono">AUC uplift (<span id="out-uplift">0.06</span>)<small>Unified scoring improvement</small></label>
            <input id="uplift" type="range" min="0" max="0.15" step="0.005" value="0.06" />
          </div>
          <div>
            <label class="mono">One‑time implementation cost ($)<small>Used for payback period</small></label>
            <input id="onetime" type="number" min="0" step="1000" value="180000" />
          </div>
        </div>
        <div class="card" style="margin-top:14px">
          <label class="mono">Advanced: baseline AUC (<span id="out-auc">0.70</span>)<small>We infer the baseline threshold and applicant bad‑rate from your approval and loss rates.</small></label>
          <input id="auc" type="range" min="0.55" max="0.90" value="0.70" step="0.005" />
        </div>
      </div>

      <!-- Results -->
      <div class="card" aria-labelledby="results-title">
        <h2 id="results-title" style="margin:0 0 10px;font-size:18px">Results</h2>
        <div class="kpi-grid" aria-live="polite">
          <div class="kpi"><div class="label">Incremental approvals / day</div><div id="k-approvals" class="value mono">—</div></div>
          <div class="kpi"><div class="label">Incremental margin / day</div><div id="k-margin" class="value mono">—</div></div>
          <div class="kpi"><div class="label">Approval lift (same loss)</div><div id="k-lift" class="value mono">—</div></div>
          <div class="kpi"><div class="label">Days to payback</div><div id="k-payback" class="value mono">—</div></div>
        </div>
        <div style="margin-top:12px" class="muted" id="calib-note"></div>
      </div>
    </section>

    <section class="card">
      <h2 style="margin:0 0 10px;font-size:18px">ROC — discrimination improves, approvals rise (loss held constant)</h2>
      <div class="chart">
        <svg id="roc" role="img" aria-label="ROC curves and operating points"></svg>
        <div class="legend">
          <span><i class="swatch" style="background:var(--vx-primary)"></i>Baseline AUC</span>
          <span><i class="swatch" style="background:var(--vx-good)"></i>Unified (AUC+uplift)</span>
          <span><i class="swatch" style="background:#888"></i>45° reference</span>
        </div>
      </div>
    </section>
  </main>

  <footer>
    <div class="container" style="display:flex;justify-content:space-between;gap:16px;flex-wrap:wrap">
      <div style="display:flex;align-items:center;gap:10px">
        <svg width="22" height="22" viewBox="0 0 64 64" aria-hidden="true"><rect x="6" y="10" width="52" height="12" rx="6" fill="#fff"/><rect x="6" y="30" width="42" height="12" rx="6" fill="#fff"/><rect x="6" y="50" width="26" height="8" rx="4" fill="#6F42C1"/></svg>
        <span class="muted" style="letter-spacing:.2em;font-size:11px">VELTRAX</span>
      </div>
      <div class="muted">Local‑first. Private by default. Built for operators who need provable ROI.</div>
    </div>
  </footer>

<script>
// ===== Math helpers (Normal CDF / invCDF, AUC↔d') =====
function erf(x){ // Abramowitz & Stegun 7.1.26
  const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911;
  const sign = x<0?-1:1; x=Math.abs(x);
  const t=1/(1+p*x);
  const y=1-((((a5*t+a4)*t+a3)*t+a2)*t+a1)*t*Math.exp(-x*x);
  return sign*y;
}
function Phi(z){return 0.5*(1+erf(z/Math.SQRT2));}
function invPhi(p){ // Peter John Acklam's rational approximation
  if(p<=0||p>=1){return p===0?-Infinity:Infinity}
  const a=[-3.969683028665376e+01,2.209460984245205e+02,-2.759285104469687e+02,1.383577518672690e+02,-3.066479806614716e+01,2.506628277459239e+00];
  const b=[-5.447609879822406e+01,1.615858368580409e+02,-1.556989798598866e+02,6.680131188771972e+01,-1.328068155288572e+01];
  const c=[-7.784894002430293e-03,-3.223964580411365e-01,-2.400758277161838e+00,-2.549732539343734e+00,4.374664141464968e+00,2.938163982698783e+00];
  const d=[7.784695709041462e-03,3.224671290700398e-01,2.445134137142996e+00,3.754408661907416e+00];
  let q,r;
  if(p<0.02425){ q=Math.sqrt(-2*Math.log(p)); return (((((c[0]*q+c[1])*q+c[2])*q+c[3])*q+c[4])*q+c[5])/((((d[0]*q+d[1])*q+d[2])*q+d[3])*q+1); }
  if(p>1-0.02425){ q=Math.sqrt(-2*Math.log(1-p)); return -(((((c[0]*q+c[1])*q+c[2])*q+c[3])*q+c[4])*q+c[5])/((((d[0]*q+d[1])*q+d[2])*q+d[3])*q+1); }
  q=p-0.5; r=q*q; return (((((a[0]*r+a[1])*r+a[2])*r+a[3])*r+a[4])*r+a[5])*q/(((((b[0]*r+b[1])*r+b[2])*r+b[3])*r+b[4])*r+1);
}
function dFromAUC(auc){ return Math.SQRT2 * invPhi(auc); } // equal-variance normals
function aucFromD(d){ return Phi(d/Math.SQRT2); }

// ===== Model pieces =====
function metricsFor(d, theta){
  const muG = d/2, muB = -d/2;
  const TPR = 1 - Phi((theta - muG));
  const FPR = 1 - Phi((theta - muB));
  return {TPR, FPR};
}
// Given d and applicant bad rate q, compute loss L(θ) and approval A(θ)
function lossAndApproval(d, theta, q){
  const {TPR,FPR} = metricsFor(d, theta);
  const pg = 1-q;
  const A = pg*TPR + q*FPR; // approval rate overall
  const L = (q*FPR) / Math.max(1e-12, A); // bads among approved
  return {L, A, TPR, FPR};
}
// Calibrate baseline: find applicant bad rate q and threshold θ that match observed approval and loss
function calibrateBaseline(d, A_obs, L_obs){
  let best=null, bestErr=1e9;
  for(let q=0.01; q<0.99; q+=0.0025){
    // bisection on θ to match loss L_obs
    let lo=-6, hi=6, Llo=lossAndApproval(d, lo, q).L, Lhi=lossAndApproval(d, hi, q).L;
    if((Llo-L_obs)*(Lhi-L_obs)>0){ continue; } // no root in range
    for(let it=0; it<50; it++){
      const mid=(lo+hi)/2; const Lmid=lossAndApproval(d, mid, q).L;
      if((Llo-L_obs)*(Lmid-L_obs)<=0){ hi=mid; Lhi=Lmid; } else { lo=mid; Llo=Lmid; }
    }
    const theta=(lo+hi)/2; const r=lossAndApproval(d, theta, q);
    const err=Math.abs(r.A - A_obs);
    if(err<bestErr){ bestErr=err; best={q, theta, A:r.A, L:r.L}; }
  }
  return best; // may be null if impossible
}
// Find threshold at same loss for a new d
function findThetaForLoss(d, q, L_target){
  let lo=-6, hi=6, Llo=lossAndApproval(d, lo, q).L, Lhi=lossAndApproval(d, hi, q).L;
  if((Llo-L_target)*(Lhi-L_target)>0){ return null; }
  for(let it=0; it<60; it++){
    const mid=(lo+hi)/2; const Lmid=lossAndApproval(d, mid, q).L;
    if((Llo-L_target)*(Lmid-L_target)<=0){ hi=mid; Lhi=Lmid; } else { lo=mid; Llo=Lmid; }
  }
  return (lo+hi)/2;
}

// ===== UI bindings =====
const $ = s=>document.querySelector(s);
const money = n=>n.toLocaleString(undefined,{style:'currency',currency:'USD',maximumFractionDigits:0});
const perc = n=> (n*100).toFixed(1)+'%';
const fmt = n=> n.toLocaleString();

['apps','approve','loss','uplift','auc'].forEach(id=>{
  $('#'+id).addEventListener('input', ()=>{syncLabels(); run();});
});
['margin','onetime'].forEach(id=> $('#'+id).addEventListener('input', run));

function syncLabels(){
  $('#out-apps').textContent = fmt(parseInt($('#apps').value));
  $('#out-approve').textContent = $('#approve').value + '%';
  $('#out-loss').textContent = parseFloat($('#loss').value).toFixed(1) + '%';
  $('#out-uplift').textContent = parseFloat($('#uplift').value).toFixed(3);
  $('#out-auc').textContent = parseFloat($('#auc').value).toFixed(2);
}

function run(){
  const apps = parseInt($('#apps').value);
  const A_obs = parseFloat($('#approve').value)/100;
  const L_obs = parseFloat($('#loss').value)/100;
  const margin = parseFloat($('#margin').value||0);
  const onetime = parseFloat($('#onetime').value||0);
  const auc0 = parseFloat($('#auc').value);
  const uplift = parseFloat($('#uplift').value); // absolute AUC uplift
  const auc1 = Math.min(0.999, auc0 + uplift);
  const d0 = dFromAUC(auc0), d1 = dFromAUC(auc1);

  const calib = calibrateBaseline(d0, A_obs, L_obs);
  if(!calib){
    $('#calib-note').textContent = 'Could not calibrate baseline with the chosen inputs. Try adjusting AUC, approval or loss.';
    ['k-approvals','k-margin','k-lift','k-payback'].forEach(id=>$('#'+id).textContent='—');
    drawROC(null);
    return;
  }
  $('#calib-note').textContent = `Calibrated applicant bad‑rate ≈ ${(calib.q*100).toFixed(1)}% (from your approval ${($('#approve').value)}% and loss ${($('#loss').value)}%).`;

  // New operating threshold for same loss under improved AUC
  const theta1 = findThetaForLoss(d1, calib.q, L_obs);
  const base = lossAndApproval(d0, calib.theta, calib.q);
  const unif = lossAndApproval(d1, theta1, calib.q);
  const lift = Math.max(0, unif.A - base.A); // approval rate lift
  const incApprovals = Math.round(lift * apps);
  const incMargin = incApprovals * margin;
  const days = incMargin>0 ? Math.ceil(onetime / incMargin) : Infinity;

  $('#k-approvals').textContent = fmt(incApprovals);
  $('#k-margin').textContent = money(incMargin);
  $('#k-lift').textContent = (lift*100).toFixed(1)+'%';
  $('#k-payback').textContent = (days===Infinity? '—' : days+' days');

  drawROC({d0, d1, q:calib.q, theta0:calib.theta, theta1});
}

function drawROC(cfg){
  const svg = $('#roc');
  while(svg.firstChild) svg.removeChild(svg.firstChild);
  const parent = svg.parentElement;
  const W = Math.max(640, parent.clientWidth);
  const H = 380; const P = 48; svg.setAttribute('viewBox',`0 0 ${W} ${H}`);
  const NS = 'http://www.w3.org/2000/svg';
  function line(x1,y1,x2,y2,stroke,w,ds){const p=document.createElementNS(NS,'line');p.setAttribute('x1',x1);p.setAttribute('y1',y1);p.setAttribute('x2',x2);p.setAttribute('y2',y2);p.setAttribute('stroke',stroke);p.setAttribute('stroke-width',w);if(ds)p.setAttribute('stroke-dasharray',ds);p.setAttribute('vector-effect','non-scaling-stroke');svg.appendChild(p);}
  function path(d,stroke,w){const p=document.createElementNS(NS,'path');p.setAttribute('d',d);p.setAttribute('fill','none');p.setAttribute('stroke',stroke);p.setAttribute('stroke-width',w);p.setAttribute('vector-effect','non-scaling-stroke');svg.appendChild(p);}
  function circle(x,y,r,fill,stroke){const c=document.createElementNS(NS,'circle');c.setAttribute('cx',x);c.setAttribute('cy',y);c.setAttribute('r',r);c.setAttribute('fill',fill||'none');if(stroke){c.setAttribute('stroke',stroke);c.setAttribute('stroke-width',2)}svg.appendChild(c);}
  function text(x,y,t,anchor='start'){const tt=document.createElementNS(NS,'text');tt.setAttribute('x',x);tt.setAttribute('y',y);tt.setAttribute('fill','var(--vx-text)');tt.setAttribute('font-size','12');tt.setAttribute('text-anchor',anchor);svg.appendChild(tt);tt.textContent=t;}

  // Axes (FPR on x, TPR on y)
  const x0=P, y0=H-P, x1=W-P, y1=P; line(x0,y0,x1,y0,'#38404f',1.2); line(x0,y0,x0,y1,'#38404f',1.2);
  text(x1, y0+18, 'False Positive Rate', 'end'); text(x0-4, y1-8, 'True Positive Rate', 'start');
  // 45°
  path(`M ${x0} ${y0} L ${x1} ${y1}`, '#888', 1.2);

  if(!cfg) return;
  function rocPath(d){
    const muG=d/2, muB=-d/2; let dstr=`M`;
    for(let t=-6;t<=6;t+=0.06){
      const T=1-Phi((t-muG)); const F=1-Phi((t-muB));
      const X=x0+(x1-x0)*F, Y=y0-(y0-y1)*T; dstr+=`${X} ${Y} `;
    }
    return dstr.trim().replace('M','M ');
  }
  // Baseline and unified paths
  path(rocPath(cfg.d0), 'var(--vx-primary)', 2.2);
  path(rocPath(cfg.d1), 'var(--vx-good)', 2.2);

  // Operating points at same loss
  function plotPoint(d,theta,color,label){
    const {TPR,FPR}=metricsFor(d,theta);
    const X=x0+(x1-x0)*FPR, Y=y0-(y0-y1)*TPR; circle(X,Y,5,color,'#000'); text(X+8,Y-6,label);
  }
  plotPoint(cfg.d0, cfg.theta0, 'var(--vx-primary)', 'Baseline');
  plotPoint(cfg.d1, cfg.theta1, 'var(--vx-good)', 'Unified');
}

syncLabels();
run();
window.addEventListener('resize', ()=> drawROC({d0:dFromAUC(parseFloat($('#auc').value)), d1:dFromAUC(Math.min(0.999, parseFloat($('#auc').value)+parseFloat($('#uplift').value))), q:0.2, theta0:0, theta1:0 })); // redraw on resize (points overridden by run)
</script>
</body>
</html>
